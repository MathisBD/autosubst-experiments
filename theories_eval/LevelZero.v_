From Prototype Require Import Prelude Sig LevelOne LevelTwo LevelTwoIrred LevelTwoSimp.

(** Concrete terms, renamings and substitutions. *)

Inductive term :=
| Var : nat -> term
| App : term -> term -> term 
| Lam : string -> term -> term.

Definition ren := nat -> nat.
Definition subst := nat -> term.

Definition rid : ren :=
  fun i => i.

Definition rshift : ren :=
  fun i => S i.

Definition rcons (i0 : nat) (r : ren) : ren :=
  fun i => match i with 0 => i0 | S i => r i end.

Definition rcomp (r1 r2 : ren) : ren :=
  fun i => r2 (r1 i).

Definition up_ren (r : ren) : ren :=
  rcons 0 (rcomp r rshift).

Fixpoint rename (t : term) (r : nat -> nat) : term :=
  match t with 
  | Var i => Var (r i)
  | App t1 t2 => App (rename t1 r) (rename t2 r)
  | Lam str t => Lam str (rename t (up_ren r))
  end.

Definition srcomp (s : subst) (r : ren) : subst :=
  fun i => rename (s i) r.
  
Definition rscomp (r : ren) (s : subst) : subst :=
  fun i => s (r i).

Definition sid : subst :=
  fun i => Var i.

Definition sshift : subst :=
  fun i => Var (S i).

Definition scons (t : term) (s : subst) : subst :=
  fun i => match i with 0 => t | S i => s i end.

Definition up_subst (s : subst) : subst :=
  scons (Var 0) (srcomp s rshift).

Fixpoint substitute (t : term) (s : subst) : term :=
  match t with 
  | Var i => s i
  | App t1 t2 => App (substitute t1 s) (substitute t2 s)
  | Lam str t => Lam str (substitute t (up_subst s))
  end.

Definition scomp (s1 s2 : subst) : subst :=
  fun i => substitute (s1 i) s2.

(** Signature. *)

Inductive base := BString.
Definition denote_base (b : base) : Type := 
  match b with BString => string end.

Inductive ctor := CApp | CLam.
Definition ctor_type c : list (@arg_ty base) := 
  match c with 
  | CApp => [ AT_term ; AT_term ]
  | CLam => [ AT_base BString ; AT_bind AT_term ]
  end.

Module S.
Definition t := Build_signature base denote_base ctor ctor_type.
End S.

Module T := LevelTwoSimp.Make (S).
Module O := T.T.T.O.

(** Reification/evaluation functions. *)

Fixpoint reify (t : term) : O.expr Kt :=
  match t with
  | Var i => O.E_var i
  | App t1 t2 =>
    O.E_ctor CApp 
      (O.E_al_cons (O.E_aterm (reify t1))
      (O.E_al_cons (O.E_aterm (reify t2))
       O.E_al_nil))
  | Lam str t =>
    O.E_ctor CLam 
      (O.E_al_cons (O.E_abase BString str)
      (O.E_al_cons (O.E_abind (O.E_aterm (reify t)))
       O.E_al_nil))
  end.

Fixpoint eval_arg (ty : arg_ty) : Type :=
  match ty with 
  | AT_base b => denote_base b 
  | AT_term => term 
  | AT_bind ty => eval_arg ty
  end.

Fixpoint eval_args (tys : list arg_ty) : Type :=
  match tys with 
  | [] => term
  | ty :: tys => eval_arg ty -> eval_args tys
  end. 

Definition eval_kind (k : kind) : Type :=
  match k with 
  | Kt => term
  | Ka ty => eval_arg ty
  | Kal tys =>   
    (** This returns a CPS type. *)
    eval_args tys -> term
  end.

Definition eval_ctor (c : ctor) : eval_args (ctor_type c) :=
  match c return eval_args (ctor_type c) with 
  | CApp => App 
  | CLam => Lam 
  end.

Fixpoint eval {k} (t : O.expr k) : eval_kind k :=
  match t in O.expr k0 return eval_kind k0 with 
  | O.E_var i => Var i 
  | O.E_ctor c al => eval al (eval_ctor c)
  | O.E_al_nil => fun x => x
  | O.E_al_cons a al => fun f => eval al (f (eval a))
  | O.E_abase b x => x 
  | O.E_aterm t => eval t 
  | O.E_abind a => eval a
  end. 

Lemma eval_reify_inv (t : term) : 
  eval (reify t) = t.
Proof. induction t ; simpl ; auto. Qed.
    
Definition sreify (s : subst) : O.subst :=
  fun i => reify (s i).

Definition seval (s : O.subst) : subst :=
  fun i => eval (s i).

Lemma seval_sreify_inv (s : subst) :
  seval (sreify s) =₁ s.
Proof. intros i ; cbv [seval sreify]. now rewrite eval_reify_inv. Qed.

Lemma eval_congr_app {t1 t1' t2 t2'} :
  t1 = t1' -> t2 = t2' -> App t1 t2 = App t1' t2'.
Proof. intros -> ->. reflexivity. Qed.

Lemma eval_congr_lam str {t t'} :
  t = t' -> Lam str t = Lam str t'.
Proof. intros ->. reflexivity. Qed.

Lemma eval_congr_scons {t t' s s'} : 
  t = t' -> s =₁ s' -> scons t s =₁ scons t' s'.
Proof. intros -> H [|i] ; [reflexivity|]. simpl. apply H. Qed.

Lemma eval_congr_substitute {t t' s s'} :
  t = t' -> s =₁ s' -> substitute t s = substitute t' s'.
Proof. intros <- H. Admitted.


(** Reification (Ltac). *)

(** Returns [(t', p)] such that [p : eval t' = t]. *)
Ltac2 rec reify (t : constr) : constr * constr :=
  lazy_match! t with 
  | Var ?i => constr:(O.E_var $i), constr:(@eq_refl _ (Var $i)) 
  | App ?t1 ?t2 => 
    let (t1', p1) := reify t1 in 
    let (t2', p2) := reify t2 in 
    let t' := constr:(
      O.E_ctor CApp 
        (O.E_al_cons (O.E_aterm $t1')
        (O.E_al_cons (O.E_aterm $t2')
         O.E_al_nil)))
    in 
    let p := constr:(eval_congr_app $p1 $p2) in
    (t', p)
  | Lam ?str ?t1 =>
    let (t1', p1) := reify t1 in
    let t' := constr:(
      O.E_ctor CLam 
        (O.E_al_cons (O.E_abase BString $str)
        (O.E_al_cons (O.E_abind (O.E_aterm $t1'))
         O.E_al_nil)))
    in 
    let p := constr:(eval_congr_lam $str $p1) in
    (t', p)
  | substitute ?t1 ?s =>
    let (t1', p1) := reify t1 in 
    let (s', p2) := reify_subst s in  
    let t' := constr:(O.substitute $t1' $s') in
    let p := constr:(eval_congr_substitute $p1 $p2) in
    (t', p)
  | ?t =>
    let t' := constr:(reify $t) in 
    let p := constr:(eval_reify_inv $t) in
    (t', p)
  end

with reify_subst (s : constr) : constr * constr :=
  lazy_match! s with 
  | scons ?t ?s1 =>
    let (t', p1) := reify t in 
    let (s1', p2) := reify_subst s1 in 
    let s' := constr:(O.scons $t' $s1') in 
    let p := constr:(eval_congr_scons $p1 $p2) in
    (s', p)
  | ?s => 
    let s' := constr:(sreify $s) in 
    let p := constr:(seval_sreify_inv $s) in 
    (s', p)
  end.

Definition t := Var 3.

Axiom t_ax : term.

Ltac2 Eval 
  let (t', p) := reify constr:(substitute t_ax (scons (Var 0) sshift)) in 
  constr:($p : eval $t' = substitute t_ax (scons (Var 0) sshift)).














Axiom r : O.ren.
Axiom x t : O.expr Kt.
Axiom s1 s2 : O.subst.

Definition left := O.substitute (O.substitute t (O.up_subst s1)) (O.scons x s2).
Definition right := O.substitute t (O.scons x (O.scomp s1 s2)).

From Ltac2 Require Import Printf.

Ltac2 test_tac () : unit :=
  lazy_match! Control.goal () with 
  | @eq _ ?l ?r => 
    let (e, l') := reify_expr (empty_env ()) l in 
    printf "%t" l' ;
    let e := build_env e in
    printf "ENV %t" e ;
    change (eeval $e $l' = $r) ;
    rewrite <-(esimp_sound $e $l')
  | _ => Control.throw_invalid_argument "not an equality"
  end.

Lemma test : left = right.
Proof.
unfold left, right, O.up_subst.
ltac2:(test_tac ()).
cbv [seval eeval seval_functional eeval_functional
     qeval reval qeval_functional reval_functional 
     assign_ren assign_qnat assign_term assign_subst nth
     esimp ssimp esimp_functional ssimp_functional 
     substitute scomp substitute_functional scomp_functional sren
     substitute_aux scomp_aux rsimp rsimp_functional qsimp_functional
     sapply qsimp sapply_functional rscomp_functional 
     sapply_aux].
Admitted.

(** Signature. *)

Module S.


End S.


Module Make (S : Sig).
Module T := LevelTwoIrred.Make (S).
Export T.
