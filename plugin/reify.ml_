(** This file reifies level zero terms/substitutions into level one terms/substitutions.
*)

open Prelude

let is_const (sigma : Evd.evar_map) (c : Names.Constant.t) (t : EConstr.t) : bool =
  match EConstr.kind sigma t with
  | Constr.Const (c', _) when Names.Constant.UserOrd.equal c c' -> true
  | _ -> false

let is_ind (sigma : Evd.evar_map) (i : Names.Ind.t) (t : EConstr.t) : bool =
  match EConstr.kind sigma t with
  | Constr.Ind (i', _) when Names.Ind.UserOrd.equal i i' -> true
  | _ -> false

let is_ctor (sigma : Evd.evar_map) (c : Names.Construct.t) (t : EConstr.t) : bool =
  match EConstr.kind sigma t with
  | Constr.Construct (c', _) when Names.Construct.UserOrd.equal c c' -> true
  | _ -> false

let dest_var (ops0 : ops_zero) (sigma : Evd.evar_map) (t : EConstr.t) : EConstr.t option =
  match EConstr.kind sigma t with
  | Constr.App (f, [| i |]) when is_ctor sigma (ops0.term, 1) f -> Some i
  | _ -> None

let dest_ctor (ops0 : ops_zero) (sigma : Evd.evar_map) (t : EConstr.t) :
    (int * EConstr.t array) option =
  match EConstr.kind sigma t with
  | Constr.App (ind, args) -> begin
      match EConstr.kind sigma ind with
      | Constr.Construct ((ind, i), _)
        when Names.Ind.UserOrd.equal ops0.term ind && 2 <= i ->
          Some (i - 2, args)
      | _ -> None
    end
  | _ -> None

let dest_substitute (ops0 : ops_zero) (sigma : Evd.evar_map) (t : EConstr.t) :
    (EConstr.t * EConstr.t) option =
  match EConstr.kind sigma t with
  | Constr.App (f, [| s; t |]) when is_const sigma ops0.substitute f -> Some (s, t)
  | _ -> None

(** [reify_term sigma t] reifies the level zero term [t] into a pair [(p, t')], such that
    [t'] is a level one term and [p] is a proof of [eval t' = t]. *)
let rec reify_term (ops0 : ops_zero) (ops1 : ops_one) (re : ops_reify_eval)
    (bij : ops_bijection) (sigma : Evd.evar_map) (t : EConstr.t) : EConstr.t * EConstr.t =
  match dest_var ops0 sigma t with
  | Some i ->
      let t' = app (mkctor ops1.e_var) i in
      let p = apps (Lazy.force Consts.eq_refl) [| mkind ops0.term; t |] in
      (p, t')
  | None -> (
      match dest_substitute ops0 sigma t with
      | Some (s, u) ->
          let p1, s' = reify_subst ops0 ops1 re bij sigma s in
          let p2, u' = reify_term ops0 ops1 re bij sigma u in
          let t' = apps (mkconst ops1.substitute) [| kt ops1; s'; u' |] in
          let p =
            apps
              (Lazy.force Consts.transitivity)
              [| mkind ops0.term
               ; apps (mkconst pe.eval_substitute) [| s'; u' |]
               ; apps (mkconst congr.congr_substitute) [| p1; p2 |]
              |]
          in
          (p, t')
      | None ->
          let t' = app (mkconst re.reify) t in
          let p = apps (mkconst bij.eval_reify_inv) t in
          (t', p))
